{"title":"GO语言工程实践及课后作业","uid":"3d68dc09ec5fbce46bc235b465b28d7d","slug":"GO语言工程实践及课后作业","date":"2023-08-11T09:54:05.000Z","updated":"2023-08-11T13:52:07.159Z","comments":true,"path":"api/articles/GO语言工程实践及课后作业.json","keywords":null,"cover":[],"content":"<h1 id=\"GO语言工程实践\"><a href=\"#GO语言工程实践\" class=\"headerlink\" title=\"GO语言工程实践\"></a>GO语言工程实践</h1><h2 id=\"一、猜谜游戏\"><a href=\"#一、猜谜游戏\" class=\"headerlink\" title=\"一、猜谜游戏\"></a>一、猜谜游戏</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">首先，我们要设置一个随机种子，然后利用这个种子来生成随机数。如果我们不使用随机种子，每次生成的随机数都会相同。接下来，我们创建了一个新的读取器（Reader）通过使用 reader :&#x3D; bufio.NewReader(os.Stdin)，并将其与标准输入流 os.Stdin 相关联。这个读取器允许我们以更高级的方式从标准输入中获取数据。\n\n随后，我们使用一个 for 循环，使用 input, err :&#x3D; reader.ReadString(&#39;\\n&#39;) 来读取输入的数据。我们将读取的输入数据与生成的随机数进行比较。如果输入数据较小&#x2F;大，我们会输出相应的提示，并要求重新输入，直到输入的数与生成的随机数相符。这样，我们就完成了一个小型的猜数字游戏。\n\n然而，在这个过程中会出现一个问题。因为输入函数会读取包括最后的换行符在内的输入内容作为字符串，所以我们需要对输入进行处理。首先，我们需要使用 strings.Trim(input, &quot;\\r\\n&quot;) 函数来去除换行符。然后，我们使用 strconv.Atoi(input) 将字符串转换为数字类型。这样才能保证后续比较和逻辑正确进行。</code></pre>\n\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;bufio&quot;\n\t&quot;fmt&quot;\n\t&quot;math&#x2F;rand&quot;\n\t&quot;os&quot;\n\t&quot;strconv&quot;\n\t&quot;strings&quot;\n\t&quot;time&quot;\n)\n\nfunc main() &#123;\n\tmaxNum :&#x3D; 100\n\trand.Seed(time.Now().UnixNano())\n\tsecretNumber :&#x3D; rand.Intn(maxNum)\n\t&#x2F;&#x2F; fmt.Println(&quot;The secret number is &quot;, secretNumber)\n\n\tfmt.Println(&quot;Please input your guess&quot;)\n\treader :&#x3D; bufio.NewReader(os.Stdin)\n\tfor &#123;\n\t\tinput, err :&#x3D; reader.ReadString(&#39;\\n&#39;)\n\t\tif err !&#x3D; nil &#123;\n\t\t\tfmt.Println(&quot;An error occured while reading input. Please try again&quot;, err)\n\t\t\tcontinue\n\t\t&#125;\n\t\tinput &#x3D; strings.Trim(input, &quot;\\r\\n&quot;)\n\n\t\tguess, err :&#x3D; strconv.Atoi(input)\n\t\tif err !&#x3D; nil &#123;\n\t\t\tfmt.Println(&quot;Invalid input. Please enter an integer value&quot;)\n\t\t\tcontinue\n\t\t&#125;\n\t\tfmt.Println(&quot;You guess is&quot;, guess)\n\t\tif guess &gt; secretNumber &#123;\n\t\t\tfmt.Println(&quot;Your guess is bigger than the secret number. Please try again&quot;)\n\t\t&#125; else if guess &lt; secretNumber &#123;\n\t\t\tfmt.Println(&quot;Your guess is smaller than the secret number. Please try again&quot;)\n\t\t&#125; else &#123;\n\t\t\tfmt.Println(&quot;Correct, you Legend!&quot;)\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n&#125;\n</code></pre>\n\n<h2 id=\"二、命令行词典\"><a href=\"#二、命令行词典\" class=\"headerlink\" title=\"二、命令行词典\"></a>二、命令行词典</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">我们将要实现一个命令行词典，其功能是在用户在命令行输入一个英文单词后，能够返回该单词的中文意思和音标。这个实现的具体过程涉及到通过调用第三方API对单词进行翻译，然后将翻译结果打印出来。\n\n在这个过程中，我们将学习如何使用Go语言来发送HTTP请求，以便与第三方API进行通信。然后，我们会学习如何解析API返回的JSON数据，从中提取出我们所需要的中文意思和音标信息。同时，我们还会探讨一些提高开发效率的技巧，以便在开发过程中能够更加高效地进行操作。\n\n总结而言，通过这个项目，我们将掌握使用Go语言实现命令行工具的方法，学会处理HTTP请求和解析JSON数据的技能，并且在实际开发中提高我们的开发效率。这将为我们未来处理类似任务时打下坚实的基础。</code></pre>\n\n<p>我们所采用的API为<a href=\"fanyi.caiyunapp.com/\">彩云科技</a>的在线翻译。</p>\n<h3 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h3><h4 id=\"1-抓包\"><a href=\"#1-抓包\" class=\"headerlink\" title=\"1.抓包\"></a>1.抓包</h4><p>在每次翻译这个动作完成的时候，我们可以发现这个过程发送了一个http请求，并且得到的结果存在response里。</p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112151803.png\" alt=\"7\"></p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112151984.png\" alt=\"7.1\"></p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112152047.png\" alt=\"7.2\"></p>\n<h4 id=\"２-代码生成\"><a href=\"#２-代码生成\" class=\"headerlink\" title=\"２.代码生成\"></a>２.代码生成</h4><p>我们将所得到的代码copycURL到网站 <a href=\"https://link.juejin.cn/?target=http://curlconverter.com/go%23\">curlconverter.com/go#</a> 中，该网站会自动生成由go语言写成的发起http请求的代码。</p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112149467.png\" alt=\"2\"></p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112149171.png\" alt=\"2.5\"></p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112148505.png\" alt=\"3\"></p>\n<h4 id=\"3-解析\"><a href=\"#3-解析\" class=\"headerlink\" title=\"3.解析\"></a>3.解析</h4><p>当我们在浏览器中收到来自服务器的响应（response）的JSON数据时，这些数据的结构可能会相当复杂。为了应对这种情况，我们可以使用 <a href=\"https://link.juejin.cn/?target=http://oktools.net/json2go/\">oktools.net/json2go/</a> 这个网站。在这个网站上，我们可以将从彩云翻译页面的响应中获取的JSON数据粘贴到指定区域，然后点击“转换嵌套”按钮，网站会自动生成相应的Go语言结构代码。这个代码会准确地反映JSON数据的结构，而无需进行其他操作。这样，我们就能轻松地将复杂的JSON数据转换为可在Go代码中使用的结构化表示。</p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112147463.png\" alt=\"4\"></p>\n<pre class=\"line-numbers language-GO\" data-language=\"GO\"><code class=\"language-GO\">package main  \n  \nimport (  \n&quot;bytes&quot;  \n&quot;encoding&#x2F;json&quot;  \n&quot;fmt&quot;  \n&quot;io&#x2F;ioutil&quot;  \n&quot;log&quot;  \n&quot;net&#x2F;http&quot;  \n&quot;os&quot;  \n)  \n  \ntype DictRequest struct &#123;  \nTransType string &#96;json:&quot;trans_type&quot;&#96;  \nSource string &#96;json:&quot;source&quot;&#96;  \nUserID string &#96;json:&quot;user_id&quot;&#96;  \n&#125;  \n  \ntype DictResponse struct &#123;  \nRc int &#96;json:&quot;rc&quot;&#96;  \nWiki struct &#123;  \nKnownInLaguages int &#96;json:&quot;known_in_laguages&quot;&#96;  \nDescription struct &#123;  \nSource string &#96;json:&quot;source&quot;&#96;  \nTarget interface&#123;&#125; &#96;json:&quot;target&quot;&#96;  \n&#125; &#96;json:&quot;description&quot;&#96;  \nID string &#96;json:&quot;id&quot;&#96;  \nItem struct &#123;  \nSource string &#96;json:&quot;source&quot;&#96;  \nTarget string &#96;json:&quot;target&quot;&#96;  \n&#125; &#96;json:&quot;item&quot;&#96;  \nImageURL string &#96;json:&quot;image_url&quot;&#96;  \nIsSubject string &#96;json:&quot;is_subject&quot;&#96;  \nSitelink string &#96;json:&quot;sitelink&quot;&#96;  \n&#125; &#96;json:&quot;wiki&quot;&#96;  \nDictionary struct &#123;  \nProns struct &#123;  \nEnUs string &#96;json:&quot;en-us&quot;&#96;  \nEn string &#96;json:&quot;en&quot;&#96;  \n&#125; &#96;json:&quot;prons&quot;&#96;  \nExplanations []string &#96;json:&quot;explanations&quot;&#96;  \nSynonym []string &#96;json:&quot;synonym&quot;&#96;  \nAntonym []string &#96;json:&quot;antonym&quot;&#96;  \nWqxExample [][]string &#96;json:&quot;wqx_example&quot;&#96;  \nEntry string &#96;json:&quot;entry&quot;&#96;  \nType string &#96;json:&quot;type&quot;&#96;  \nRelated []interface&#123;&#125; &#96;json:&quot;related&quot;&#96;  \nSource string &#96;json:&quot;source&quot;&#96;  \n&#125; &#96;json:&quot;dictionary&quot;&#96;  \n&#125;  \n  \nfunc query(word string) &#123;  \nclient :&#x3D; &amp;http.Client&#123;&#125;  &#x2F;&#x2F;创建一个http client，这个函数还可以指定最大的返回时间\nrequest :&#x3D; DictRequest&#123;TransType: &quot;en2zh&quot;, Source: word&#125;  \nbuf, err :&#x3D; json.Marshal(request)  &#x2F;&#x2F;设置一个request结构体，将json序列化\nif err !&#x3D; nil &#123;  \nlog.Fatal(err)  \n&#125;  \nvar data &#x3D; bytes.NewReader(buf)  \nreq, err :&#x3D; http.NewRequest(&quot;POST&quot;, &quot;https:&#x2F;&#x2F;api.interpreter.caiyunai.com&#x2F;v1&#x2F;dict&quot;, data) \n&#x2F;&#x2F;生成一个http请求 \nif err !&#x3D; nil &#123;  \nlog.Fatal(err)  \n&#125; \n\n&#x2F;&#x2F;设置请求头\nreq.Header.Set(&quot;Connection&quot;, &quot;keep-alive&quot;)  \nreq.Header.Set(&quot;DNT&quot;, &quot;1&quot;)  \nreq.Header.Set(&quot;os-version&quot;, &quot;&quot;)  \nreq.Header.Set(&quot;sec-ch-ua-mobile&quot;, &quot;?0&quot;)  \nreq.Header.Set(&quot;User-Agent&quot;, &quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;99.0.4844.51 Safari&#x2F;537.36&quot;)  \nreq.Header.Set(&quot;app-name&quot;, &quot;xy&quot;)  \nreq.Header.Set(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;)  \nreq.Header.Set(&quot;Accept&quot;, &quot;application&#x2F;json, text&#x2F;plain, *&#x2F;*&quot;)  \nreq.Header.Set(&quot;device-id&quot;, &quot;&quot;)  \nreq.Header.Set(&quot;os-type&quot;, &quot;web&quot;)  \nreq.Header.Set(&quot;X-Authorization&quot;, &quot;token:qgemv4jr1y38jyq6vhvi&quot;)  \nreq.Header.Set(&quot;Origin&quot;, &quot;https:&#x2F;&#x2F;fanyi.caiyunapp.com&quot;)  \nreq.Header.Set(&quot;Sec-Fetch-Site&quot;, &quot;cross-site&quot;)  \nreq.Header.Set(&quot;Sec-Fetch-Mode&quot;, &quot;cors&quot;)  \nreq.Header.Set(&quot;Sec-Fetch-Dest&quot;, &quot;empty&quot;)  \nreq.Header.Set(&quot;Referer&quot;, &quot;https:&#x2F;&#x2F;fanyi.caiyunapp.com&#x2F;&quot;)  \nreq.Header.Set(&quot;Accept-Language&quot;, &quot;zh-CN,zh;q&#x3D;0.9&quot;)  \nreq.Header.Set(&quot;Cookie&quot;, &quot;_ym_uid&#x3D;16456948721020430059; _ym_d&#x3D;1645694872&quot;)  \n\nresp, err :&#x3D; client.Do(req)  &#x2F;&#x2F;真正发起请求\nif err !&#x3D; nil &#123;  \nlog.Fatal(err)  \n&#125;  \ndefer resp.Body.Close()  &#x2F;&#x2F;按照go的习惯，需要手动关闭resp流，defer的意思是在函数结束后关闭，释放内存\nbodyText, err :&#x3D; ioutil.ReadAll(resp.Body)  \nif err !&#x3D; nil &#123;  \nlog.Fatal(err)  \n&#125;  \nif resp.StatusCode !&#x3D; 200 &#123;  &#x2F;&#x2F;得到的response不一定正确，需要检测一下返回的状态码\nlog.Fatal(&quot;bad StatusCode:&quot;, resp.StatusCode, &quot;body&quot;, string(bodyText))  \n&#125;  \nvar dictResponse DictResponse  \nerr &#x3D; json.Unmarshal(bodyText, &amp;dictResponse)  &#x2F;&#x2F;构造一个与json相同的结构体，并将json序列化到这个结构体变量里面\nif err !&#x3D; nil &#123;  \nlog.Fatal(err)  \n&#125;  \nfmt.Println(word, &quot;UK:&quot;, dictResponse.Dictionary.Prons.En, &quot;US:&quot;, dictResponse.Dictionary.Prons.EnUs)  &#x2F;&#x2F;得到音标\nfor _, item :&#x3D; range dictResponse.Dictionary.Explanations &#123;  &#x2F;&#x2F;得到解释\nfmt.Println(item)  \n&#125;  \n&#125;  \n  \nfunc main() &#123;  \nif len(os.Args) !&#x3D; 2 &#123;  \nfmt.Fprintf(os.Stderr, &#96;usage: simpleDict WORD  \nexample: simpleDict hello  \n&#96;)  \nos.Exit(1)  \n&#125;  \nword :&#x3D; os.Args[1]  \nquery(word)  \n&#125;\n\t</code></pre>\n\n<h2 id=\"三、SOCKS5代理\"><a href=\"#三、SOCKS5代理\" class=\"headerlink\" title=\"三、SOCKS5代理\"></a>三、SOCKS5代理</h2><h3 id=\"SOCKS5介绍\"><a href=\"#SOCKS5介绍\" class=\"headerlink\" title=\"SOCKS5介绍\"></a>SOCKS5介绍</h3><p>SOCKS5 (Socket Secure 5) 是一种网络协议，主要用于在客户端和服务器之间进行数据传输，特别适用于代理服务器。它是 SOCKS 协议的第五个版本，在此之前的版本的基础上增加了更多的功能和安全性。</p>\n<p>主要特点和用途如下：</p>\n<ol>\n<li><p><strong>代理功能</strong>：SOCKS5 协议的核心功能是允许客户端通过代理服务器进行网络连接。客户端将请求发送给代理服务器，代理服务器则代表客户端与目标服务器建立连接，实现客户端的网络访问。</p>\n</li>\n<li><p><strong>支持 TCP 和 UDP</strong>：SOCKS5 协议同时支持 TCP 和 UDP 两种传输协议。这使得客户端可以通过 SOCKS5 代理服务器连接到目标服务器的 TCP 或 UDP 端口，这在某些应用中如远程访问、P2P 等方面非常有用。</p>\n</li>\n<li><p><strong>身份验证</strong>：SOCKS5 支持用户名和密码的身份验证机制。在连接代理服务器时，客户端可以提供用户名和密码，以便代理服务器验证用户身份的合法性。</p>\n</li>\n<li><p><strong>IPv6 支持</strong>：SOCKS5 协议不仅支持传统的 IPv4 地址，还支持 IPv6 地址。这使得客户端可以通过代理服务器连接到目标服务器的 IPv6 地址。</p>\n</li>\n<li><p><strong>防火墙穿越</strong>：SOCKS5 协议可以帮助用户绕过防火墙的限制，从而实现跨境访问被封锁的网站或服务。</p>\n</li>\n<li><p><strong>匿名性</strong>：通过使用 SOCKS5，目标服务器只能看到 SOCKS5 代理服务器的 IP 地址，而无法直接获取到客户端的真实 IP 地址，从而提供一定程度的匿名性。</p>\n</li>\n</ol>\n<p>需要注意的是，SOCKS5 是一种基于应用层的协议，与基于传输层的代理协议如 HTTP/HTTPS 不同。它能够与各种应用程序一起使用，无需对这些应用程序进行额外的配置。由于 SOCKS5 协议具备强大的代理功能和灵活性，它在许多场景下得到广泛应用，包括网络隐私保护、翻墙、加速等各种应用。</p>\n<h3 id=\"SOCKS5工作原理\"><a href=\"#SOCKS5工作原理\" class=\"headerlink\" title=\"SOCKS5工作原理\"></a>SOCKS5工作原理</h3><p>SOCKS5（Socket Secure 5）协议是一种用于数据传输和身份验证的协议，其工作原理涉及客户端、代理服务器和目标服务器之间的交互。下面是 SOCKS5 协议的详细工作流程：</p>\n<ol>\n<li><p><strong>客户端发送连接请求</strong>：<br>当客户端需要连接目标服务器时，它向 SOCKS5 代理服务器发送连接请求。这个请求包含目标服务器的地址、端口号，以及所需的身份验证方式（如果需要）。</p>\n</li>\n<li><p><strong>代理服务器进行身份验证（可选）</strong>：<br>如果客户端需要身份验证，代理服务器会验证客户端提供的用户名和密码。这一步骤为数据传输提供一定的安全性和授权访问。</p>\n</li>\n<li><p><strong>代理服务器与目标服务器建立连接</strong>：<br>代理服务器在收到客户端的连接请求后，代表客户端与目标服务器建立连接，成为中间人。</p>\n</li>\n<li><p><strong>数据传输</strong>：<br>一旦代理服务器与目标服务器建立连接，它成为客户端与目标服务器之间的桥梁。代理服务器将客户端发送的所有数据转发到目标服务器，同时将目标服务器的响应传回客户端。</p>\n</li>\n<li><p><strong>连接关闭</strong>：<br>当客户端或目标服务器关闭连接时，代理服务器会终止与两者之间的连接，完成数据传输过程。</p>\n</li>\n</ol>\n<p>SOCKS5 协议的特点在于它支持 TCP 和 UDP 两种传输协议，并提供身份验证功能。这使得 SOCKS5 协议在代理网络连接方面具备出色的灵活性和功能强大的特点。它能够与各种应用程序协同工作，而无需对这些应用程序进行额外的设置，因为它操作在应用层而非传输层。</p>\n<p>通过这种工作方式，SOCKS5 协议不仅使用户能够绕过防火墙限制，实现跨境访问被封锁的网站或服务，还为用户提供一定程度的网络匿名性。这是因为目标服务器只能看到 SOCKS5 代理服务器的 IP 地址，而无法直接获取客户端的真实 IP 地址。</p>\n<p><img src=\"https://gitee.com/ImgsBed_1_1/imgsbed/raw/master/Img/202308112147638.png\" alt=\"6\"></p>\n<h2 id=\"课后作业\"><a href=\"#课后作业\" class=\"headerlink\" title=\"课后作业\"></a>课后作业</h2><h3 id=\"修改猜谜游戏里面的最终代码，使用-fmt-Scanf-来简化代码实现\"><a href=\"#修改猜谜游戏里面的最终代码，使用-fmt-Scanf-来简化代码实现\" class=\"headerlink\" title=\"修改猜谜游戏里面的最终代码，使用 fmt.Scanf 来简化代码实现\"></a>修改猜谜游戏里面的最终代码，使用 fmt.Scanf 来简化代码实现</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main  \n  \nimport (  \n&quot;fmt&quot;  \n&quot;math&#x2F;rand&quot;  \n&quot;time&quot;  \n)  \n  \nfunc main() &#123;  \nmaxNum :&#x3D; 100  \nrand.Seed(time.Now().UnixNano())  \nsecretNumber :&#x3D; rand.Intn(maxNum)  \n&#x2F;&#x2F; fmt.Println(&quot;The secret number is &quot;, secretNumber)  \n  \nfmt.Println(&quot;Please input your guess&quot;)  \nvar guess int  \nfor &#123;  \nfmt.Scan(&amp;guess)  \nfmt.Println(&quot;You guess is&quot;, guess)  \nif guess &gt; secretNumber &#123;  \nfmt.Println(&quot;Your guess is bigger than the secret number. Please try again&quot;)  \n&#125; else if guess &lt; secretNumber &#123;  \nfmt.Println(&quot;Your guess is smaller than the secret number. Please try again&quot;)  \n&#125; else &#123;  \nfmt.Println(&quot;Correct, you Legend!&quot;)  \nbreak  \n&#125;  \n&#125;  \n&#125;\n</code></pre>\n\n","text":"GO语言工程实践一、猜谜游戏首先，我们要设置一个随机种子，然后利用这个种子来生成随机数。如果我们不使用随机种子，每次生成的随机数都会相同。接下来，我们创建了一个新的读取器（Reader）通过使用 reader :&#x3D; bufio.NewReader(os.Stdin)，并...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#GO%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">GO语言工程实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">一、猜谜游戏</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%8D%E5%85%B8\"><span class=\"toc-text\">二、命令行词典</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">实现步骤</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%8A%93%E5%8C%85\"><span class=\"toc-text\">1.抓包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%92-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90\"><span class=\"toc-text\">２.代码生成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">3.解析</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81SOCKS5%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">三、SOCKS5代理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SOCKS5%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">SOCKS5介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SOCKS5%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">SOCKS5工作原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A\"><span class=\"toc-text\">课后作业</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%BF%E7%94%A8-fmt-Scanf-%E6%9D%A5%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">修改猜谜游戏里面的最终代码，使用 fmt.Scanf 来简化代码实现</span></a></li></ol></li></ol></li></ol>","author":{"name":"Abysmiler","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/03/28/pp6jU9s.jpg","link":"/","description":"落日沉溺于橘色的海，晚风沦陷于赤诚的爱。","socials":{"github":"https://github.com/Abysmiler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"高质量编程与性能调优实战","uid":"a565a86cfb39770fa7fc7acb1580eb15","slug":"高质量编程与性能调优实战","date":"2023-08-14T10:24:55.000Z","updated":"2023-08-14T13:34:13.824Z","comments":true,"path":"api/articles/高质量编程与性能调优实战.json","keywords":null,"cover":null,"text":"高质量编程与性能调优实战这是我参与「第三届青训营 -后端场」笔记创作活动的的第3篇笔记 课程主要分为两个部分，分别是高质量编程和性能调优实战。其中高质量编程多是一些指导性原则，辅以一些示例进行讲解，加上课程PPT以及导学链接中已经总结得很清晰完善，所以本篇笔记仅记录一些个人的知识...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Abysmiler","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/03/28/pp6jU9s.jpg","link":"/","description":"落日沉溺于橘色的海，晚风沦陷于赤诚的爱。","socials":{"github":"https://github.com/Abysmiler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"后端入门--GO语言学习","uid":"e38cf29d68826256ee0466da40a4b793","slug":"后端入门-GO语言学习","date":"2023-07-25T07:15:40.000Z","updated":"2023-07-25T15:55:12.108Z","comments":true,"path":"api/articles/后端入门-GO语言学习.json","keywords":null,"cover":[],"text":"DAY1 Go 语言基础语法走进Go语言基础语法什么是Go语言1.高性能、高并发 2.语法简单、学习曲线平缓 3.丰富的标准库 4.完善的工具链 5.静态链接 6.快速编译 7.跨平台 8.垃圾回收 示例： 哪些公司在使用Go语言 基础语法Hello Worldpackage m...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[],"author":{"name":"Abysmiler","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/03/28/pp6jU9s.jpg","link":"/","description":"落日沉溺于橘色的海，晚风沦陷于赤诚的爱。","socials":{"github":"https://github.com/Abysmiler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}