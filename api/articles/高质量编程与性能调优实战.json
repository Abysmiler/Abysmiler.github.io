{"title":"高质量编程与性能调优实战","uid":"a565a86cfb39770fa7fc7acb1580eb15","slug":"高质量编程与性能调优实战","date":"2023-08-14T10:24:55.000Z","updated":"2023-08-14T13:34:13.824Z","comments":true,"path":"api/articles/高质量编程与性能调优实战.json","keywords":null,"cover":null,"content":"<h1 id=\"高质量编程与性能调优实战\"><a href=\"#高质量编程与性能调优实战\" class=\"headerlink\" title=\"高质量编程与性能调优实战\"></a>高质量编程与性能调优实战</h1><p>这是我参与「第三届青训营 -后端场」笔记创作活动的的第3篇笔记</p>\n<p>课程主要分为两个部分，分别是高质量编程和性能调优实战。其中高质量编程多是一些指导性原则，辅以一些示例进行讲解，加上课程PPT以及导学链接中已经总结得很清晰完善，所以本篇笔记仅记录一些个人的知识点记忆以及列出不太熟悉的知识要点。</p>\n<h2 id=\"高质量编程\"><a href=\"#高质量编程\" class=\"headerlink\" title=\"高质量编程\"></a>高质量编程</h2><h3 id=\"高质量代码\"><a href=\"#高质量代码\" class=\"headerlink\" title=\"高质量代码\"></a>高质量代码</h3><p>编写的代码能够达到正确可靠、简洁清晰的目标可称之为高质量代码</p>\n<ul>\n<li>各种边界条件是否考虑完备</li>\n<li>异常情况处理，稳定性保证</li>\n<li>易读易维护</li>\n</ul>\n<h3 id=\"编程原则\"><a href=\"#编程原则\" class=\"headerlink\" title=\"编程原则\"></a>编程原则</h3><ul>\n<li><p>简单性</p>\n<ul>\n<li>消除“多余的复杂性”，以简单清晰的逻辑编写代码</li>\n<li>不理解的代码无法修复改进</li>\n</ul>\n</li>\n<li><p>可读性</p>\n<ul>\n<li>代码是给人看的，而不是机器</li>\n<li>编写可维护代码的第一步是确保代码可读</li>\n</ul>\n</li>\n<li><p>生产力</p>\n<ul>\n<li>团队整体工作效率非常重要</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编码规范\"><a href=\"#编码规范\" class=\"headerlink\" title=\"编码规范\"></a>编码规范</h3><ul>\n<li><p>代码格式</p>\n<ul>\n<li>推荐使用gofmt自动格式化代码</li>\n<li>gofmt：Go语言官方提供的工具，能自动格式化Go语言代码为官方统一风格</li>\n<li>goimports:Go语言官方提供的工具，实际等于gofmt加上依赖包管理，自动增删依赖的包引用、将依赖包按字母序排序并分类</li>\n</ul>\n</li>\n<li><p>注释的应用</p>\n<ul>\n<li>解释代码的功能，描述公共符号的用途。</li>\n<li>描述代码的实现过程，说明公共符号的实际实现方法。</li>\n<li>阐述代码的原因，提供外部因素的背景信息，为代码提供额外上下文。</li>\n<li>指出代码可能出错的情况，限制条件的说明。</li>\n</ul>\n</li>\n<li><p>公共符号的注释</p>\n<ul>\n<li>所有公共符号都必须注释，包括在包中声明的变量、常量、函数以及结构等。</li>\n<li>对于不明显或简短的公共功能，同样需要添加注释。</li>\n<li>不论函数在库中的长度或复杂程度如何，都必须进行注释。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h3><ul>\n<li><p>变量</p>\n<ul>\n<li>简洁的命名优于冗长的命名。</li>\n<li>缩略词通常使用全大写，但如果缩略词在变量开头且不需要导出，则使用全小写。</li>\n<li>变量与其使用位置的距离越远，需要携带越多的上下文信息。</li>\n</ul>\n</li>\n<li><p>函数</p>\n<ul>\n<li>函数名不需要携带包名的上下文信息，因为包名和函数名总是成对出现。</li>\n<li>函数名应该简短明了。</li>\n<li>若某个包内名为 “foo” 的函数返回类型 “Foo”，可以省略类型信息以避免歧义。</li>\n<li>若某个包内名为 “foo” 的函数返回类型 “T”，可以在函数名中加入类型信息。</li>\n</ul>\n</li>\n<li><p>包</p>\n<ul>\n<li>包名只能由小写字母组成，不包含大写字母和下划线等字符。</li>\n<li>包名应该简短且包含一定的上下文信息，例如 “schema”、”task” 等。</li>\n<li>避免与标准库重名，例如不要使用 “sync” 或 “strings”。</li>\n<li>避免使用常用变量名作为包名，例如使用 “bufio” 而不是 “buf”。</li>\n<li>使用单数形式而非复数。</li>\n<li>对缩写的使用要谨慎。</li>\n</ul>\n</li>\n<li><p>控制流程</p>\n<ul>\n<li>避免过多的嵌套，保持正常流程的清晰性。</li>\n<li>如果两个分支都包含 return 语句，可以去掉多余的 else 分支。</li>\n<li>尽量保持正常代码路径的最小缩进。</li>\n<li>优先处理错误和特殊情况，以减少嵌套。</li>\n<li>尽量保持代码逻辑的线性，避免复杂的嵌套分支。</li>\n<li>正常流程代码应该顺着屏幕向下移动，以提高可读性和可维护性。</li>\n<li>这些原则将有助于提升代码的可维护性和可读性，同时减少故障问题在复杂条件和循环中的出现。</li>\n</ul>\n</li>\n<li><p>错误和异常处理</p>\n<ul>\n<li>对于简单错误，如仅出现一次且不需要在其他地方捕获的错误，使用 <code>errors.New</code> 创建匿名变量表示。</li>\n<li>如果需要格式化，可以使用 <code>fmt.Errorf</code>。</li>\n<li>错误的 Wrap 和 Unwrap 机制可以创建错误的跟踪链，通过 <code>%w</code> 关键字关联错误。</li>\n<li>使用 <code>errors.Is</code> 判定特定错误，而非使用 <code>==</code>，这样可以判定错误链上是否包含特定错误。</li>\n<li>在错误链中获取特定种类的错误，使用 <code>errors.As</code>。</li>\n<li>避免在业务代码中使用 <code>panic</code>，除非是启动阶段的不可逆转错误。</li>\n<li><code>recover</code> 只在被 <code>defer</code> 的函数中有效，不支持嵌套，只在当前 Goroutine 生效。</li>\n<li><code>defer</code> 语句遵循后进先出的原则。</li>\n<li>如果需要更多上下文信息，可以在 <code>recover</code> 后记录当前调用栈。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><ul>\n<li><p>性能基准测试命令：<code>go test -bench=. -benchmem</code></p>\n</li>\n<li><p>性能优化建议：</p>\n<ul>\n<li><p>对于切片，应预先分配内存。</p>\n</li>\n<li><p>在使用<code>make()</code>初始化切片时，尽量提供容量信息。</p>\n</li>\n<li><p>另一个潜在问题是未释放大内存：</p>\n<ul>\n<li>基于已有切片创建新切片不会产生新的底层数组。</li>\n<li>场景：原切片较大，代码在原切片基础上创建小切片。</li>\n<li>原底层数组因仍被引用而无法释放。</li>\n<li>**建议使用<code>copy</code>代替<code>re-slice</code>**。</li>\n</ul>\n</li>\n<li><p>在使用map时，应预先分配内存。</p>\n<ul>\n<li>频繁地向map中添加元素会触发map的扩容。</li>\n<li>预先分配空间可以减少内存拷贝和Rehash的开销。</li>\n<li>根据实际需求提前预估所需空间是明智之举。</li>\n</ul>\n</li>\n<li><p>字符串处理：</p>\n<ul>\n<li>使用<code>+</code>拼接性能较差，<code>strings.Builder</code>和<code>bytes.Buffer</code>相似，但<code>strings.Builder</code>更快。</li>\n<li>在Go语言中，字符串是不可变类型，占用固定内存。</li>\n<li>使用<code>+</code>时每次重新分配内存。</li>\n<li><code>strings.Builder</code>和<code>bytes.Buffer</code>底层均是[]byte数组。</li>\n<li><code>bytes.Buffer</code>转化为字符串时重新分配了一块内存。</li>\n<li><code>strings.Builder</code>直接将底层的[]byte转换为字符串类型。</li>\n<li>内存扩容策略避免了每次拼接都重新分配内存。</li>\n<li>使用<code>strings.Builder</code>进行字符串拼接。</li>\n</ul>\n</li>\n<li><p>利用空结构体节省内存：</p>\n<ul>\n<li>使用空结构体<code>struct&#123;&#125;</code>可以节省内存。</li>\n<li>空结构体实例不占用内存空间。</li>\n<li>可用作各种场景下的占位符，节省资源。</li>\n<li>空结构体具备明确的语义，表示这里不需要任何值，只作为占位符。</li>\n<li>在实现Set时，可用map来代替。</li>\n<li>对于该场景，只需使用map的键，无需值。</li>\n<li>即使将map的值设为bool类型，仍会占用1个字节空间。</li>\n</ul>\n</li>\n<li><p>使用<code>atomic</code>包：</p>\n<ul>\n<li>锁是通过操作系统实现的，涉及系统调用。</li>\n<li><code>atomic</code>操作是通过硬件实现的，效率高于锁。</li>\n<li><code>sync.Mutex</code>应用于保护一段逻辑，不仅限于保护单个变量。</li>\n<li>对于非数值操作，可使用<code>atomic.Value</code>，能够容纳<code>interface&#123;&#125;</code>类型。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"性能调优实战\"><a href=\"#性能调优实战\" class=\"headerlink\" title=\"性能调优实战\"></a>性能调优实战</h2><p><strong>性能调优原则</strong>：</p>\n<ol>\n<li><strong>数据驱动优化</strong>：基于实际数据进行调优，而不是仅仅猜测或臆测。</li>\n<li><strong>定位瓶颈</strong>：重点关注最大的瓶颈，不要过多关注细枝末节。</li>\n<li><strong>避免过早优化</strong>：在了解问题之前不要进行过度的优化。</li>\n<li><strong>避免过度优化</strong>：不要花费过多精力在微小的性能改进上。</li>\n</ol>\n<p><strong>性能分析工具pprof</strong>：</p>\n<p>pprof是一款用于可视化和分析性能数据的工具，它提供了多种功能来帮助定位和解决性能问题。</p>\n<ol>\n<li><p><strong>火焰图</strong>：</p>\n<ul>\n<li>以垂直的方式表示函数调用顺序。</li>\n<li>每个方块代表一个函数，方块的长度与该函数占用的CPU时间成比例。</li>\n<li>火焰图是交互式的，点击方块可以进一步分析函数的性能。</li>\n</ul>\n</li>\n<li><p><strong>采样过程与原理</strong>：</p>\n<ul>\n<li><p><strong>CPU采样</strong>：</p>\n<ul>\n<li>采样对象：记录函数调用及其占用的时间。</li>\n<li>采样率：每秒采样100次，固定值。</li>\n<li>采样时间：从手动启动到手动结束。</li>\n</ul>\n</li>\n<li><p><strong>堆内存采样</strong>：</p>\n<ul>\n<li>通过内存分配器追踪堆上的内存分配和释放，记录大小和数量。</li>\n<li>采样率：每分配512kb记录一次，可在运行开始时进行修改，1表示每次分配都记录。</li>\n<li>采样时间：从程序运行开始到采样时。</li>\n<li>采样指标：分配空间、分配对象、已使用空间、已使用对象。</li>\n<li>计算方式：已使用 = 分配 - 释放。</li>\n</ul>\n</li>\n<li><p><strong>Goroutine采样</strong>：</p>\n<ul>\n<li>记录所有正在运行的用户发起的goroutine的调用栈信息，以及runtime.main的调用栈。</li>\n</ul>\n</li>\n<li><p><strong>ThreadCreate采样</strong>：</p>\n<ul>\n<li>记录程序创建的所有系统线程信息。</li>\n</ul>\n</li>\n<li><p><strong>阻塞采样</strong>：</p>\n<ul>\n<li>采样阻塞操作的次数和耗时。</li>\n<li>采样率：只记录耗时超过阈值的阻塞操作，1表示每次阻塞都记录。</li>\n</ul>\n</li>\n<li><p><strong>锁采样</strong>：</p>\n<ul>\n<li>记录争夺锁的次数和耗时。</li>\n<li>采样率：只记录固定比例的锁操作，1表示每次加锁都记录。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><h2 id=\"性能调优案例\"><a href=\"#性能调优案例\" class=\"headerlink\" title=\"性能调优案例\"></a>性能调优案例</h2><p><strong>业务服务优化：</strong></p>\n<ul>\n<li>一个“服务”是一个能够独立部署的程序，它承载着特定的功能。</li>\n<li>当一个服务的功能实现需要依赖另一个服务的响应结果时，称为一个服务依赖另一个服务。</li>\n<li>“调用链路”是指一组相关的服务，它们一起支持一个接口请求，并且它们之间存在依赖关系。</li>\n<li>“基础库”是指公共的工具包和中间件。</li>\n</ul>\n<p><strong>基础库优化：</strong></p>\n<ul>\n<li>优化AB实验SDK。<ul>\n<li>这包括分析基础库核心逻辑以及性能瓶颈。<ul>\n<li>在分析的基础上，设计改进方案。</li>\n<li>根据需要获取数据，避免不必要的数据获取。</li>\n<li>优化数据序列化协议。</li>\n</ul>\n</li>\n<li>通过内部的压力测试来验证这些优化。</li>\n<li>在业务服务中推广并验证这些优化。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Go语言优化：</strong></p>\n<ul>\n<li>对编译器和运行时进行优化。<ul>\n<li>为了优化内存分配，重新考虑内存分配策略。</li>\n<li>优化代码的编译流程，以生成更高效的程序。</li>\n<li>同样，通过内部压力测试来验证这些优化。</li>\n<li>最终，将这些优化推广到业务服务中，并在实际落地中验证它们的效果。</li>\n</ul>\n</li>\n<li>Go语言的优势包括：<ul>\n<li>简单的接入方式，只需要调整编译配置。</li>\n<li>高度的通用性，适用于各种应用场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"高质量编程与性能调优实战这是我参与「第三届青训营 -后端场」笔记创作活动的的第3篇笔记 课程主要分为两个部分，分别是高质量编程和性能调优实战。其中高质量编程多是一些指导性原则，辅以一些示例进行讲解，加上课程PPT以及导学链接中已经总结得很清晰完善，所以本篇笔记仅记录一些个人的知识...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">高质量编程与性能调优实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E8%B4%A8%E9%87%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">高质量编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">高质量代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A8%8B%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">编程原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">编码规范</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">命名规范</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">性能优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">性能调优实战</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">性能调优案例</span></a></li></ol></li></ol>","author":{"name":"Abysmiler","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/03/28/pp6jU9s.jpg","link":"/","description":"落日沉溺于橘色的海，晚风沦陷于赤诚的爱。","socials":{"github":"https://github.com/Abysmiler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"使用 GORM（Go 的 ORM 库）连接数据库，并实现增删改查操作","uid":"08ed117ef6641c202bf4a939efc3aec0","slug":"库）连接数据库，并实现增删改查操作","date":"2023-08-15T18:25:35.000Z","updated":"2023-08-15T18:46:19.243Z","comments":true,"path":"api/articles/库）连接数据库，并实现增删改查操作.json","keywords":null,"cover":null,"text":"使用 GORM（Go 的 ORM 库）连接数据库，并实现增删改查操作前言本篇文章为面向用户层面的掌握 Go 语言基础以及了解 MySQL数据库，读完本篇文章，读者可以了解ORM框架的定义和熟悉使用GORM包进行基本的CRUD。 GORMGORM是Go语言的一个ORM(Object...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[],"author":{"name":"Abysmiler","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/03/28/pp6jU9s.jpg","link":"/","description":"落日沉溺于橘色的海，晚风沦陷于赤诚的爱。","socials":{"github":"https://github.com/Abysmiler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"GO语言工程实践及课后作业","uid":"3d68dc09ec5fbce46bc235b465b28d7d","slug":"GO语言工程实践及课后作业","date":"2023-08-11T09:54:05.000Z","updated":"2023-08-11T13:52:07.159Z","comments":true,"path":"api/articles/GO语言工程实践及课后作业.json","keywords":null,"cover":[],"text":"GO语言工程实践一、猜谜游戏首先，我们要设置一个随机种子，然后利用这个种子来生成随机数。如果我们不使用随机种子，每次生成的随机数都会相同。接下来，我们创建了一个新的读取器（Reader）通过使用 reader :&#x3D; bufio.NewReader(os.Stdin)，并...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"Abysmiler","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/03/28/pp6jU9s.jpg","link":"/","description":"落日沉溺于橘色的海，晚风沦陷于赤诚的爱。","socials":{"github":"https://github.com/Abysmiler","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}